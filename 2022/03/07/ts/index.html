<!DOCTYPE html><html class="appearance-auto" lang="zh-CN"><head><meta charset="UTF-8"><title>Typescript总结</title><meta name="description" content="记录一下学习和生活"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.ico"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="TypeScript中的基本类型TypeScript中的基本类型：

类型声明

类型声明是TS非常重要的一个特点；

通过类型声明可以指定TS中变量（参数、形参）的类型；

指定类型后，当为变量赋值时，TS编译器会自动检查值是否符合类型声明，符合则赋值，否则报错；

简而言之，类型声明给变量设置了类型，使得变量只能存储某种类型的值；

语法：


let 变量: 类型;
let 变量: 类型 &amp;#x3D; 值;
function fn(参数: 类型, 参数: 类型): 类型{   …}






自动类型判断

TS拥有自动的类型判断机制
当对变量的声明和赋值是同时进行的，TS编译器会自动判断变量的类型
所以如果你的变量的声明和赋值时同时进行的，可以省略掉类型声明


类型：



类型
例子
描述

.."><meta name="generator" content="Hexo 6.0.0"><link rel="alternate" href="/atom.xml" title="Haloer-kay" type="application/atom+xml">
</head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">Haloer-kay's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Typescript总结</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">点击返回顶部</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#TypeScript%E4%B8%AD%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="toc-text">TypeScript中的基本类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E9%80%89%E9%A1%B9"><span class="toc-text">编译选项</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E7%BC%96%E8%AF%91%E6%96%87%E4%BB%B6"><span class="toc-text">自动编译文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E7%BC%96%E8%AF%91%E6%95%B4%E4%B8%AA%E9%A1%B9%E7%9B%AE"><span class="toc-text">自动编译整个项目</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#include"><span class="toc-text">include</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#exclude"><span class="toc-text">exclude</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#extends"><span class="toc-text">extends</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#files"><span class="toc-text">files</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#compilerOptions"><span class="toc-text">compilerOptions</span></a></li></ol></li></ol></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/typescript"><i class="tag post-item-tag">typescript</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">Typescript总结</h1><time class="has-text-grey" datetime="2022-03-07T13:14:02.300Z">2022-03-07</time><article class="mt-2 post-content"><h2 id="TypeScript中的基本类型"><a href="#TypeScript中的基本类型" class="headerlink" title="TypeScript中的基本类型"></a><strong>TypeScript中的基本类型</strong></h2><p>TypeScript中的基本类型：</p>
<ul>
<li><p>类型声明</p>
<ul>
<li><p>类型声明是TS非常重要的一个特点；</p>
</li>
<li><p>通过类型声明可以指定TS中变量（参数、形参）的类型；</p>
</li>
<li><p>指定类型后，当为变量赋值时，TS编译器会自动检查值是否符合类型声明，符合则赋值，否则报错；</p>
</li>
<li><p>简而言之，类型声明给变量设置了类型，使得变量只能存储某种类型的值；</p>
</li>
<li><p>语法：</p>
<ul>
<li><blockquote>
<p>let 变量: 类型;</p>
<p>let 变量: 类型 &#x3D; 值;</p>
<p>function fn(参数: 类型, 参数: 类型): 类型{<br>   …<br>}</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li><p>自动类型判断</p>
<ul>
<li>TS拥有自动的类型判断机制</li>
<li>当对变量的声明和赋值是同时进行的，TS编译器会自动判断变量的类型</li>
<li>所以如果你的变量的声明和赋值时同时进行的，可以省略掉类型声明</li>
</ul>
</li>
<li><p>类型：</p>
<table>
<thead>
<tr>
<th><strong>类型</strong></th>
<th><strong>例子</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>number</td>
<td>1, -33, 2.5</td>
<td>任意数字</td>
</tr>
<tr>
<td>string</td>
<td>‘hi’, “hi”, <code>hi</code></td>
<td>任意字符串</td>
</tr>
<tr>
<td>boolean</td>
<td>true、false</td>
<td>布尔值true或false</td>
</tr>
<tr>
<td>字面量</td>
<td>其本身</td>
<td>限制变量的值就是该字面量的值</td>
</tr>
<tr>
<td>any</td>
<td>*</td>
<td>任意类型</td>
</tr>
<tr>
<td>unknown</td>
<td>*</td>
<td>类型安全的any</td>
</tr>
<tr>
<td>void</td>
<td>空值（undefined）</td>
<td>没有值（或undefined）</td>
</tr>
<tr>
<td>never</td>
<td>没有值</td>
<td>不能是任何值</td>
</tr>
<tr>
<td>object</td>
<td>{name:’孙悟空’}</td>
<td>任意的JS对象</td>
</tr>
<tr>
<td>array</td>
<td>[1,2,3]</td>
<td>任意JS数组</td>
</tr>
<tr>
<td>tuple</td>
<td>[4,5]</td>
<td>元素，TS新增类型，固定长度数组</td>
</tr>
<tr>
<td>enum</td>
<td>enum{A, B}</td>
<td>枚举，TS中新增类型</td>
</tr>
</tbody></table>
</li>
<li><p>number</p>
<ul>
<li><blockquote>
<p>let decimal: number &#x3D; 6;<br>let hex: number &#x3D; 0xf00d;<br>let binary: number &#x3D; 0b1010;<br>let octal: number &#x3D; 0o744;<br>let big: bigint &#x3D; 100n;</p>
</blockquote>
</li>
</ul>
</li>
<li><p>boolean</p>
<ul>
<li><blockquote>
<p>let isDone: boolean &#x3D; false;</p>
</blockquote>
</li>
</ul>
</li>
<li><p>string</p>
<ul>
<li><blockquote>
<p>let color: string &#x3D; “blue”;<br>color &#x3D; ‘red’;</p>
<p>let fullName: string &#x3D; <code>Bob Bobbington</code>;<br>let age: number &#x3D; 37;<br>let sentence: string &#x3D; &#96;Hello, my name is ${fullName}.</p>
<p>I’ll be ${age + 1} years old next month.&#96;;</p>
</blockquote>
</li>
</ul>
</li>
<li><p>字面量</p>
<ul>
<li><p>也可以使用字面量去指定变量的类型，通过字面量可以确定变量的取值范围</p>
</li>
<li><blockquote>
<p>let color: ‘red’ | ‘blue’ | ‘black’;<br>let num: 1 | 2 | 3 | 4 | 5;</p>
</blockquote>
</li>
</ul>
</li>
<li><p>any</p>
<ul>
<li><blockquote>
<p>let d: any &#x3D; 4;<br>d &#x3D; ‘hello’;<br>d &#x3D; true;</p>
</blockquote>
</li>
</ul>
</li>
<li><p>unknown</p>
<ul>
<li><blockquote>
<p>let notSure: unknown &#x3D; 4;<br>notSure &#x3D; ‘hello’;</p>
</blockquote>
</li>
</ul>
</li>
<li><p>void</p>
<ul>
<li><blockquote>
<p>let unusable: void &#x3D; undefined;</p>
</blockquote>
</li>
</ul>
</li>
<li><p>never</p>
<ul>
<li><blockquote>
<p>function error(message: string): never {<br> throw new Error(message);<br>}</p>
</blockquote>
</li>
</ul>
</li>
<li><p>object（没啥用）</p>
<ul>
<li><blockquote>
<p>let obj: object &#x3D; {};</p>
</blockquote>
</li>
</ul>
</li>
<li><p>array</p>
<ul>
<li><blockquote>
<p>let list: number[] &#x3D; [1, 2, 3];<br>let list: Array<number> &#x3D; [1, 2, 3];</p>
</blockquote>
</li>
</ul>
</li>
<li><p>tuple</p>
<ul>
<li><blockquote>
<p>let x: [string, number];<br>x &#x3D; [“hello”, 10];</p>
</blockquote>
</li>
</ul>
</li>
<li><p>enum</p>
<ul>
<li><blockquote>
<p>enum Color {<br> Red,<br> Green,<br> Blue,<br>}<br>let c: Color &#x3D; Color.Green;</p>
<p>enum Color {<br> Red &#x3D; 1,<br> Green,<br> Blue,<br>}<br>let c: Color &#x3D; Color.Green;</p>
<p>enum Color {<br> Red &#x3D; 1,<br> Green &#x3D; 2,<br> Blue &#x3D; 4,<br>}<br>let c: Color &#x3D; Color.Green;</p>
</blockquote>
</li>
</ul>
</li>
<li><p>类型断言</p>
<ul>
<li><p>有些情况下，变量的类型对于我们来说是很明确，但是TS编译器却并不清楚，此时，可以通过类型断言来告诉编译器变量的类型，断言有两种形式：</p>
<ul>
<li><p>第一种</p>
<ul>
<li>&#96;&#96;&#96;<br>let someValue: unknown &#x3D; “this is a string”;<br>let strLength: number &#x3D; (someValue as string).length;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 第二种</span><br><span class="line"></span><br><span class="line">  - ```</span><br><span class="line">    let someValue: unknown = &quot;this is a string&quot;;</span><br><span class="line">    let strLength: number = (&lt;string&gt;someValue).length;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="编译选项"><a href="#编译选项" class="headerlink" title="编译选项"></a>编译选项</h2><h3 id="自动编译文件"><a href="#自动编译文件" class="headerlink" title="自动编译文件"></a>自动编译文件</h3><p>编译文件时，使用 -w 指令后，TS编译器会自动监视文件的变化，并在文件发生变化时对文件进行重新编译。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc xxx.ts -w</span><br></pre></td></tr></table></figure>

<h3 id="自动编译整个项目"><a href="#自动编译整个项目" class="headerlink" title="自动编译整个项目"></a>自动编译整个项目</h3><p>如果直接使用tsc指令，则可以自动将当前项目下的所有ts文件编译为js文件。</p>
<p><strong>但是能直接使用tsc命令的前提时，要先在项目根目录下创建一个ts的配置文件 tsconfig.json</strong></p>
<p>tsconfig.json是一个JSON文件，添加配置文件后，只需只需 tsc 命令即可完成对整个项目的编译</p>
<p>配置选项：</p>
<h4 id="include"><a href="#include" class="headerlink" title="include"></a><strong>include</strong></h4><ul>
<li>定义希望被编译文件所在的目录</li>
<li>默认值：[“**&#x2F;*”]</li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;include&quot;:[&quot;src/**/*&quot;, &quot;tests/**/*&quot;]</span><br></pre></td></tr></table></figure>

<p>上述示例中，所有src目录和tests目录下的文件都会被编译</p>
<h4 id="exclude"><a href="#exclude" class="headerlink" title="exclude"></a><strong>exclude</strong></h4><ul>
<li>定义需要排除在外的目录</li>
<li>默认值：[“node_modules”, “bower_components”, “jspm_packages”]</li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;exclude&quot;: [&quot;./src/hello/**/*&quot;]</span><br></pre></td></tr></table></figure>

<p>上述示例中，src下hello目录下的文件都不会被编译</p>
<h4 id="extends"><a href="#extends" class="headerlink" title="extends"></a><strong>extends</strong></h4><ul>
<li>定义被继承的配置文件</li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;extends&quot;: &quot;./configs/base&quot;</span><br></pre></td></tr></table></figure>

<p>上述示例中，当前配置文件中会自动包含config目录下base.json中的所有配置信息</p>
<h4 id="files"><a href="#files" class="headerlink" title="files"></a><strong>files</strong></h4><ul>
<li>指定被编译文件的列表，<strong>只有需要编译的文件少时才会用到</strong></li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&quot;files&quot;: [</span><br><span class="line">    &quot;core.ts&quot;,</span><br><span class="line">    &quot;sys.ts&quot;,</span><br><span class="line">    &quot;types.ts&quot;,</span><br><span class="line">    &quot;scanner.ts&quot;,</span><br><span class="line">    &quot;parser.ts&quot;,</span><br><span class="line">    &quot;utilities.ts&quot;,</span><br><span class="line">    &quot;binder.ts&quot;,</span><br><span class="line">    &quot;checker.ts&quot;,</span><br><span class="line">    &quot;tsc.ts&quot;</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure>

<ul>
<li>列表中的文件都会被TS编译器所编译</li>
</ul>
<h4 id="compilerOptions"><a href="#compilerOptions" class="headerlink" title="compilerOptions"></a>compilerOptions</h4><ul>
<li>编译选项是配置文件中非常重要也比较复杂的配置选项</li>
<li>在compilerOptions中包含多个子选项，用来完成对编译的配置</li>
</ul>
<p>项目选项：</p>
<ul>
<li><p>target</p>
<ul>
<li><p>设置ts代码编译的目标版本</p>
</li>
<li><p>可选值：</p>
<ul>
<li>ES3（默认）、ES5、ES6&#x2F;ES2015、ES7&#x2F;ES2016、ES2017、ES2018、ES2019、ES2020、ESNext</li>
</ul>
</li>
<li><p>示例：</p>
<ul>
<li>&#96;&#96;&#96;<br>“compilerOptions”: {<br>“target”: “ES6”<br>}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 如上设置，我们所编写的ts代码将会被编译为ES6版本的js代码</span><br><span class="line"></span><br><span class="line">- lib</span><br><span class="line"></span><br><span class="line">  - 指定代码运行时所包含的库（宿主环境）</span><br><span class="line"></span><br><span class="line">  - 可选值：</span><br><span class="line"></span><br><span class="line">    - ES5、ES6/ES2015、ES7/ES2016、ES2017、ES2018、ES2019、ES2020、ESNext、DOM、WebWorker、ScriptHost ......</span><br><span class="line"></span><br><span class="line">  - 示例：</span><br><span class="line"></span><br><span class="line">    - ```</span><br><span class="line">      &quot;compilerOptions&quot;: &#123;</span><br><span class="line">          &quot;target&quot;: &quot;ES6&quot;,</span><br><span class="line">          &quot;lib&quot;: [&quot;ES6&quot;, &quot;DOM&quot;],</span><br><span class="line">          &quot;outDir&quot;: &quot;dist&quot;,</span><br><span class="line">          &quot;outFile&quot;: &quot;dist/aa.js&quot;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>module</p>
<ul>
<li><p>设置编译后代码使用的模块化系统</p>
</li>
<li><p>可选值：</p>
<ul>
<li>CommonJS、UMD、AMD、System、ES2020、ESNext、None</li>
</ul>
</li>
<li><p>示例：</p>
<ul>
<li><pre><code>&quot;compilerOptions&quot;: &#123;
    &quot;module&quot;: &quot;CommonJS&quot;
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- outDir</span><br><span class="line"></span><br><span class="line">  - 编译后文件的所在目录</span><br><span class="line"></span><br><span class="line">  - 默认情况下，编译后的js文件会和ts文件位于相同的目录，设置outDir后可以改变编译后文件的位置</span><br><span class="line"></span><br><span class="line">  - 示例：</span><br><span class="line"></span><br><span class="line">    - ```</span><br><span class="line">      &quot;compilerOptions&quot;: &#123;</span><br><span class="line">          &quot;outDir&quot;: &quot;dist&quot;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>设置后编译后的js文件将会生成到dist目录</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>outFile</p>
<ul>
<li><p>将所有的文件编译为一个js文件</p>
</li>
<li><p>默认会将所有的编写在全局作用域中的代码合并为一个js文件，如果module制定了None、System或AMD则会将模块一起合并到文件之中</p>
</li>
<li><p>示例：</p>
<ul>
<li>&#96;&#96;&#96;<br>“compilerOptions”: {<br>“outFile”: “dist&#x2F;app.js”<br>}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- rootDir</span><br><span class="line"></span><br><span class="line">  - 指定代码的根目录，默认情况下编译后文件的目录结构会以最长的公共目录为根目录，通过rootDir可以手动指定根目录</span><br><span class="line"></span><br><span class="line">  - 示例：</span><br><span class="line"></span><br><span class="line">    - ```</span><br><span class="line">      &quot;compilerOptions&quot;: &#123;</span><br><span class="line">          &quot;rootDir&quot;: &quot;./src&quot;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>allowJs</p>
<ul>
<li>是否对js文件编译</li>
</ul>
</li>
<li><p>checkJs</p>
<ul>
<li><p>是否对js文件进行检查</p>
</li>
<li><p>示例：</p>
<ul>
<li>&#96;&#96;&#96;<br>“compilerOptions”: {<br>“allowJs”: true,<br>“checkJs”: true<br>}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- removeComments</span><br><span class="line"></span><br><span class="line">  - 是否删除注释</span><br><span class="line">  - 默认值：false</span><br><span class="line"></span><br><span class="line">- noEmit</span><br><span class="line"></span><br><span class="line">  - 不对代码进行编译</span><br><span class="line">  - 默认值：false</span><br><span class="line"></span><br><span class="line">- sourceMap</span><br><span class="line"></span><br><span class="line">  - 是否生成sourceMap</span><br><span class="line">  - 默认值：false</span><br><span class="line"></span><br><span class="line">- 严格检查</span><br><span class="line"></span><br><span class="line">  - strict</span><br><span class="line">    - 启用所有的严格检查，默认值为true，设置后相当于开启了所有的严格检查</span><br><span class="line">  - alwaysStrict</span><br><span class="line">    - 总是以严格模式对代码进行编译</span><br><span class="line">  - noImplicitAny</span><br><span class="line">    - 禁止隐式的any类型</span><br><span class="line">  - noImplicitThis</span><br><span class="line">    - 禁止类型不明确的this</span><br><span class="line">  - strictBindCallApply</span><br><span class="line">    - 严格检查bind、call和apply的参数列表</span><br><span class="line">  - strictFunctionTypes</span><br><span class="line">    - 严格检查函数的类型</span><br><span class="line">  - strictNullChecks</span><br><span class="line">    - 严格的空值检查</span><br><span class="line">  - strictPropertyInitialization</span><br><span class="line">    - 严格检查属性是否初始化</span><br><span class="line"></span><br><span class="line">- 额外检查</span><br><span class="line"></span><br><span class="line">  - noFallthroughCasesInSwitch</span><br><span class="line">    - 检查switch语句包含正确的break</span><br><span class="line">  - noImplicitReturns</span><br><span class="line">    - 检查函数没有隐式的返回值</span><br><span class="line">  - noUnusedLocals</span><br><span class="line">    - 检查未使用的局部变量</span><br><span class="line">  - noUnusedParameters</span><br><span class="line">    - 检查未使用的参数</span><br><span class="line"></span><br><span class="line">- 高级</span><br><span class="line"></span><br><span class="line">  - allowUnreachableCode</span><br><span class="line">    - 检查不可达代码</span><br><span class="line">    - 可选值：</span><br><span class="line">      - true，忽略不可达代码</span><br><span class="line">      - false，不可达代码将引起错误</span><br><span class="line">  - noEmitOnError</span><br><span class="line">    - 有错误的情况下不进行编译</span><br><span class="line">    - 默认值：false</span><br><span class="line"></span><br><span class="line">## 面向对象</span><br><span class="line"></span><br><span class="line">要想面向对象，操作对象，首先便要拥有对象；</span><br><span class="line"></span><br><span class="line">要创建对象，必须要先定义类，所谓的类可以理解为对象的模型；</span><br><span class="line"></span><br><span class="line">程序中可以根据类创建指定类型的对象；</span><br><span class="line"></span><br><span class="line">举例来说：</span><br><span class="line"></span><br><span class="line">可以通过Person类来创建人的对象，通过Dog类创建狗的对象，不同的类可以用来创建不同的对象；</span><br><span class="line"></span><br><span class="line">### 定义类</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>class 类名 {<br>    属性名: 类型;</p>
<pre><code>constructor(参数: 类型)&#123;
    this.属性名 = 参数;
&#125;

方法名()&#123;
    ....
&#125;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">示例：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<pre><code>class Person&#123;
    name: string;
    age: number;

    constructor(name: string, age: number)&#123;
        this.name = name;
        this.age = age;
    &#125;

    sayHello()&#123;
        console.log(`大家好，我是$&#123;this.name&#125;`);
    &#125;
&#125;
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">使用类：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>const p &#x3D; new Person(‘孙悟空’, 18);<br>p.sayHello();</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 构造函数</span><br><span class="line"></span><br><span class="line">可以使用`constructor`定义一个构造器方法；</span><br><span class="line"></span><br><span class="line">&gt; **注1：在TS中只能有一个构造器方法！**</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>class C{<br>    name: string;<br>    age: number</p>
<pre><code>constructor(name: string, age: number) &#123;
    this.name = name;
    this.age = age;
&#125;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">同时也可以直接将属性定义在构造函数中：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>class C {<br>    constructor(public name: string, public age: number) {<br>    }<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">上面两种定义方法是完全相同的！</span><br><span class="line"></span><br><span class="line">**注2：子类继承父类时，必须调用父类的构造方法（如果子类中也定义了构造方法）！**</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>class A {<br>    protected num: number;<br>    constructor(num: number) {<br>        this.num &#x3D; num;<br>    }<br>}</p>
<p>class X extends A {<br>    protected name: string;<br>    constructor(num: number, name: string) {<br>        super(num);<br>        this.name &#x3D; name;<br>    }<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">如果在X类中不调用`super`将会报错！</span><br><span class="line"></span><br><span class="line">### 封装</span><br><span class="line"></span><br><span class="line">对象实质上就是属性和方法的容器，它的主要作用就是存储属性和方法，这就是所谓的封装</span><br><span class="line"></span><br><span class="line">默认情况下，对象的属性是可以任意的修改的，为了确保数据的安全性，在TS中可以对属性的权限进行设置</span><br><span class="line"></span><br><span class="line">- 静态属性（static）：</span><br><span class="line">  - 声明为static的属性或方法不再属于实例，而是属于类的属性；</span><br><span class="line">- 只读属性（readonly）：</span><br><span class="line">  - 如果在声明属性时添加一个readonly，则属性便成了只读属性无法修改</span><br><span class="line">- TS中属性具有三种修饰符：</span><br><span class="line">  - public（默认值），可以在类、子类和对象中修改</span><br><span class="line">  - protected ，可以在类、子类中修改</span><br><span class="line">  - private ，可以在类中修改</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line"></span><br><span class="line">public：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>class Person{<br>    public name: string; &#x2F;&#x2F; 写或什么都不写都是public<br>    public age: number;</p>
<pre><code>constructor(name: string, age: number)&#123;
    this.name = name; // 可以在类中修改
    this.age = age;
&#125;

sayHello()&#123;
    console.log(`大家好，我是$&#123;this.name&#125;`);
&#125;
</code></pre>
<p>}</p>
<p>class Employee extends Person{<br>    constructor(name: string, age: number){<br>        super(name, age);<br>        this.name &#x3D; name; &#x2F;&#x2F;子类中可以修改<br>    }<br>}</p>
<p>const p &#x3D; new Person(‘孙悟空’, 18);<br>p.name &#x3D; ‘猪八戒’;&#x2F;&#x2F; 可以通过对象修改</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">protected：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>class Person{<br>    protected name: string;<br>    protected age: number;</p>
<pre><code>constructor(name: string, age: number)&#123;
    this.name = name; // 可以修改
    this.age = age;
&#125;

sayHello()&#123;
    console.log(`大家好，我是$&#123;this.name&#125;`);
&#125;
</code></pre>
<p>}</p>
<p>class Employee extends Person{</p>
<pre><code>constructor(name: string, age: number)&#123;
    super(name, age);
    this.name = name; //子类中可以修改
&#125;
</code></pre>
<p>}</p>
<p>const p &#x3D; new Person(‘孙悟空’, 18);<br>p.name &#x3D; ‘猪八戒’;&#x2F;&#x2F; 不能修改</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">private：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>class Person{<br>    private name: string;<br>    private age: number;</p>
<pre><code>constructor(name: string, age: number)&#123;
    this.name = name; // 可以修改
    this.age = age;
&#125;

sayHello()&#123;
    console.log(`大家好，我是$&#123;this.name&#125;`);
&#125;
</code></pre>
<p>}</p>
<p>class Employee extends Person{</p>
<pre><code>constructor(name: string, age: number)&#123;
    super(name, age);
    this.name = name; //子类中不能修改
&#125;
</code></pre>
<p>}</p>
<p>const p &#x3D; new Person(‘孙悟空’, 18);<br>p.name &#x3D; ‘猪八戒’;&#x2F;&#x2F; 不能修改</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 属性存取器</span><br><span class="line"></span><br><span class="line">对于一些不希望被任意修改的属性，可以将其设置为private</span><br><span class="line"></span><br><span class="line">直接将其设置为private将导致无法再通过对象修改其中的属性</span><br><span class="line"></span><br><span class="line">我们可以在类中定义一组读取、设置属性的方法，这种对属性读取或设置的属性被称为属性的存取器</span><br><span class="line"></span><br><span class="line">读取属性的方法叫做setter方法，设置属性的方法叫做getter方法</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>class Person{<br>    private _name: string;</p>
<pre><code>constructor(name: string)&#123;
    this._name = name;
&#125;

get name()&#123;
    return this._name;
&#125;

set name(name: string)&#123;
    this._name = name;
&#125;
</code></pre>
<p>}</p>
<p>const p1 &#x3D; new Person(‘孙悟空’);<br>&#x2F;&#x2F; 实际通过调用getter方法读取name属性<br>console.log(p1.name);<br>&#x2F;&#x2F; 实际通过调用setter方法修改name属性<br>p1.name &#x3D; ‘猪八戒’; </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 静态属性</span><br><span class="line"></span><br><span class="line">静态属性（方法），也称为类属性。使用静态属性无需创建实例，通过类即可直接使用</span><br><span class="line"></span><br><span class="line">静态属性（方法）使用static开头</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>class Tools{<br>    static PI &#x3D; 3.1415926;</p>
<pre><code>static sum(num1: number, num2: number)&#123;
    return num1 + num2
&#125;
</code></pre>
<p>}</p>
<p>console.log(Tools.PI);<br>console.log(Tools.sum(123, 456));</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### this</span><br><span class="line"></span><br><span class="line">在类中，使用this表示当前对象</span><br><span class="line"></span><br><span class="line">### 继承</span><br><span class="line"></span><br><span class="line">继承时面向对象中的又一个特性</span><br><span class="line"></span><br><span class="line">通过继承可以将其他类中的属性和方法引入到当前类中</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>class Animal{<br>    name: string;<br>    age: number;</p>
<pre><code>constructor(name: string, age: number)&#123;
    this.name = name;
    this.age = age;
&#125;
</code></pre>
<p>}</p>
<p>class Dog extends Animal{</p>
<pre><code>bark()&#123;
    console.log(`$&#123;this.name&#125;在汪汪叫！`);
&#125;
</code></pre>
<p>}</p>
<p>const dog &#x3D; new Dog(‘旺财’, 4);<br>dog.bark();</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">通过继承可以在不修改类的情况下完成对类的扩展</span><br><span class="line"></span><br><span class="line">### 重写</span><br><span class="line"></span><br><span class="line">发生继承时，如果子类中的方法会替换掉父类中的同名方法，这就称为方法的重写</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>class Animal{<br>    name: string;<br>    age: number;</p>
<pre><code>constructor(name: string, age: number)&#123;
    this.name = name;
    this.age = age;
&#125;

run()&#123;
    console.log(`父类中的run方法！`);
&#125;
</code></pre>
<p>}</p>
<p>class Dog extends Animal{</p>
<pre><code>bark()&#123;
    console.log(`$&#123;this.name&#125;在汪汪叫！`);
&#125;

run()&#123;
    console.log(`子类中的run方法，会重写父类中的run方法！`);
&#125;
</code></pre>
<p>}</p>
<p>const dog &#x3D; new Dog(‘旺财’, 4);<br>dog.bark();</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**在子类中可以使用super来完成对父类的引用**</span><br><span class="line"></span><br><span class="line">### 抽象类（abstract class）</span><br><span class="line"></span><br><span class="line">抽象类是专门用来被其他类所继承的类，它只能被其他类所继承不能用来创建实例</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>abstract class Animal{<br>  abstract run(): void;<br>  bark(){<br>      console.log(‘动物在叫~’);<br>  }<br>}</p>
<p>class Dog extends Animals{<br>  run(){<br>      console.log(‘狗在跑~’);<br>  }<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">使用abstract开头的方法叫做抽象方法，抽象方法没有方法体只能定义在抽象类中，继承抽象类时抽象方法必须要实现;</span><br><span class="line"></span><br><span class="line">## 接口（Interface）</span><br><span class="line"></span><br><span class="line">接口的作用类似于抽象类，不同点在于：接口中的所有方法和属性都是没有实值的，换句话说接口中的所有方法都是抽象方法；</span><br><span class="line"></span><br><span class="line">接口主要负责定义一个类的结构，接口可以去限制一个对象的接口：对象只有包含接口中定义的所有属性和方法时才能匹配接口；</span><br><span class="line"></span><br><span class="line">同时，可以让一个类去实现接口，实现接口时类中要保护接口中的所有属性；</span><br><span class="line"></span><br><span class="line">示例（检查对象类型）：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>interface Person{<br>    name: string;<br>    sayHello():void;<br>}</p>
<p>function fn(per: Person){<br>    per.sayHello();<br>}</p>
<p>fn({name:’孙悟空’, sayHello() {console.log(<code>Hello, 我是 $&#123;this.name&#125;</code>)}});</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">示例（实现）：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>interface Person{<br>   name: string;<br>   sayHello():void;<br>}</p>
<p>class Student implements Person{<br>   constructor(public name: string) {<br>   }</p>
<p>   sayHello() {<br>       console.log(‘大家好，我是’+this.name);<br>   }<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 泛型（Generic）</span><br><span class="line"></span><br><span class="line">定义一个函数或类时，有些情况下无法确定其中要使用的具体类型（返回值、参数、属性的类型不能确定）；</span><br><span class="line"></span><br><span class="line">此时泛型便能够发挥作用；</span><br><span class="line"></span><br><span class="line">举个例子：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>function test(arg: any): any{<br>    return arg;<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">上例中，test函数有一个参数类型不确定，但是能确定的时其返回值的类型和参数的类型是相同的；</span><br><span class="line"></span><br><span class="line">由于类型不确定所以参数和返回值均使用了any，但是很明显这样做是不合适的：</span><br><span class="line"></span><br><span class="line">首先使用any会关闭TS的类型检查，其次这样设置也不能体现出参数和返回值是相同的类型；</span><br><span class="line"></span><br><span class="line">### 泛型函数</span><br><span class="line"></span><br><span class="line">#### 创建泛型函数</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>function test<T>(arg: T): T{<br>    return arg;<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">这里的`&lt;T&gt;`就是泛型；</span><br><span class="line"></span><br><span class="line">T是我们给这个类型起的名字（不一定非叫T），设置泛型后即可在函数中使用T来表示该类型；</span><br><span class="line"></span><br><span class="line">所以泛型其实很好理解，就表示某个类型；</span><br><span class="line"></span><br><span class="line">那么如何使用上边的函数呢？</span><br><span class="line"></span><br><span class="line">#### 使用泛型函数</span><br><span class="line"></span><br><span class="line">##### 方式一（直接使用）：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>test(10)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">使用时可以直接传递参数使用，类型会由TS自动推断出来，但有时编译器无法自动推断时还需要使用下面的方式</span><br><span class="line"></span><br><span class="line">##### 方式二（指定类型）：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>test<number>(10)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">也可以在函数后手动指定泛型；</span><br><span class="line"></span><br><span class="line">#### 函数中声明多个泛型</span><br><span class="line"></span><br><span class="line">可以同时指定多个泛型，泛型间使用逗号隔开：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>function test&lt;T, K&gt;(a: T, b: K): K{<br>  return b;<br>}</p>
<p>test&lt;number, string&gt;(10, “hello”);</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">使用泛型时，完全可以将泛型当成是一个普通的类去使用；</span><br><span class="line"></span><br><span class="line">### 泛型类</span><br><span class="line"></span><br><span class="line">类中同样可以使用泛型：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>class MyClass<T>{<br>  prop: T;</p>
<p>  constructor(prop: T){<br>      this.prop &#x3D; prop;<br>  }<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 泛型继承</span><br><span class="line"></span><br><span class="line">除此之外，也可以对泛型的范围进行约束</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>interface MyInter{<br>  length: number;<br>}</p>
<p>function test<T extends MyInter>(arg: T): number{<br>  return arg.length;<br>}</p>
<pre><code>
使用T extends MyInter表示泛型T必须是MyInter的子类，不一定非要使用接口类和抽象类同样适用；

# refs

- [TypeScript 入门教程](https://ts.xcatliu.com/)
- [深入理解 TypeScript](https://jkchao.github.io/typescript-book-chinese/)
- [TS官方文档](https://www.tslang.cn/docs/home.html)
- [TS与各框架整合官方案例](https://www.tslang.cn/samples/index.html)
</code></pre>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><em></em><a class="button is-default" href="/2022/03/07/index/" title="第一篇博客"><span class="has-text-weight-semibold">下一页: 第一篇博客</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container"><script async repo="Haloer-kay" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/haloer-kay"><i class="iconfont icon-github"></i></a><!-- Ins--><!-- RSS--><!-- 知乎--><a title="zhihu" target="_blank" rel="noopener nofollow" href="//zhihu.com//"><i class="iconfont icon-zhihu"></i></a><!-- 领英--><!-- 脸书--></section><p><span>Copyright ©</span><span> Haloer-kay 2022</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" target="_blank" rel="noopener" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" target="_blank" rel="noopener" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/post.js"></script></body></html>